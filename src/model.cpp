// Generated by dust (version 0.15.3) - do not edit
#include <cpp11.hpp>

[[cpp11::register]]
cpp11::sexp dust_model_gpu_info();
[[cpp11::register]]
SEXP dust_cpu_model_alloc(cpp11::list r_pars, bool pars_multi, cpp11::sexp r_time,
                         cpp11::sexp r_n_particles, int n_threads,
                         cpp11::sexp r_seed, bool deterministic,
                         cpp11::sexp gpu_config, cpp11::sexp ode_control);

[[cpp11::register]]
cpp11::sexp dust_cpu_model_capabilities();

[[cpp11::register]]
SEXP dust_cpu_model_run(SEXP ptr, cpp11::sexp r_time_end);

[[cpp11::register]]
SEXP dust_cpu_model_simulate(SEXP ptr, cpp11::sexp time_end);

[[cpp11::register]]
SEXP dust_cpu_model_run_adjoint(SEXP ptr);

[[cpp11::register]]
SEXP dust_cpu_model_set_index(SEXP ptr, cpp11::sexp r_index);

[[cpp11::register]]
SEXP dust_cpu_model_update_state(SEXP ptr, SEXP r_pars, SEXP r_state,
                                           SEXP r_time, SEXP r_set_initial_state,
                                           SEXP index, SEXP reset_step_size);

[[cpp11::register]]
SEXP dust_cpu_model_state(SEXP ptr, SEXP r_index);

[[cpp11::register]]
SEXP dust_cpu_model_time(SEXP ptr);

[[cpp11::register]]
void dust_cpu_model_reorder(SEXP ptr, cpp11::sexp r_index);

[[cpp11::register]]
SEXP dust_cpu_model_resample(SEXP ptr, cpp11::doubles r_weights);

[[cpp11::register]]
SEXP dust_cpu_model_rng_state(SEXP ptr, bool first_only, bool last_only);

[[cpp11::register]]
SEXP dust_cpu_model_set_rng_state(SEXP ptr, cpp11::raws rng_state);

[[cpp11::register]]
SEXP dust_cpu_model_set_data(SEXP ptr, cpp11::list data, bool shared);

[[cpp11::register]]
SEXP dust_cpu_model_compare_data(SEXP ptr);

[[cpp11::register]]
SEXP dust_cpu_model_filter(SEXP ptr, SEXP time_end,
                                     bool save_trajectories,
                                     cpp11::sexp time_snapshot,
                                     cpp11::sexp min_log_likelihood);

[[cpp11::register]]
void dust_cpu_model_set_n_threads(SEXP ptr, int n_threads);

[[cpp11::register]]
int dust_cpu_model_n_state(SEXP ptr);

[[cpp11::register]]
void dust_cpu_model_set_stochastic_schedule(SEXP ptr, SEXP time);

[[cpp11::register]]
SEXP dust_cpu_model_ode_statistics(SEXP ptr);
#include <dust/r/dust.hpp>

// Generated by odin.dust (version 0.3.13) - do not edit
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum1(const container x, size_t from, size_t to);
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum2(const container x, int from_i, int to_i, int from_j, int to_j, int dim_x_1);
// [[dust::class(model)]]
// [[dust::time_type(discrete)]]
// [[dust::param(capacity, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(gene_no, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(Genotypes, has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(GPSC_no, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(m, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(Pop_eq, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(Pop_mig_dist, has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(Pop_start, has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(prop_f, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(sero_no, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(sigma_f, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(v, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_time, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vaccTypes, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(dt, has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
class model {
public:
  using real_type = double;
  using rng_state_type = dust::random::generator<real_type>;
  using data_type = dust::no_data;
  struct shared_type {
    real_type capacity;
    std::vector<real_type> delta;
    int dim_delta;
    int dim_eq;
    int dim_freq;
    int dim_gene_eq;
    int dim_gene_eq_1;
    int dim_gene_eq_2;
    int dim_gene_freq;
    int dim_gene_freq_1;
    int dim_gene_freq_2;
    int dim_Genotypes;
    int dim_Genotypes_1;
    int dim_Genotypes_2;
    int dim_pi_f_freq;
    int dim_pi_f_freq_1;
    int dim_pi_f_freq_2;
    int dim_pi_f_genotypes;
    int dim_Pop;
    int dim_Pop_1;
    int dim_Pop_2;
    int dim_Pop_eq;
    int dim_Pop_mig;
    int dim_Pop_mig_1;
    int dim_Pop_mig_2;
    int dim_Pop_mig_dist;
    int dim_Pop_mig_dist_1;
    int dim_Pop_mig_dist_2;
    int dim_Pop_start;
    int dim_Pop_start_1;
    int dim_Pop_start_2;
    int dim_Pop_tot;
    int dim_probs;
    int dim_probs_1;
    int dim_probs_2;
    int dim_vaccTypes;
    int dim_y;
    int dim_y_1;
    int dim_y_2;
    real_type dt;
    std::vector<real_type> eq;
    std::vector<real_type> gene_eq;
    int gene_no;
    std::vector<real_type> Genotypes;
    int GPSC_no;
    std::vector<real_type> initial_Pop;
    std::vector<real_type> initial_Pop_tot;
    real_type initial_time;
    real_type m;
    int offset_variable_Pop;
    std::vector<real_type> Pop_eq;
    std::vector<real_type> Pop_mig_dist;
    std::vector<real_type> Pop_start;
    real_type prop_f;
    int sero_no;
    real_type sigma_f;
    real_type v;
    real_type vacc_time;
    std::vector<real_type> vaccTypes;
  };
  struct internal_type {
    std::vector<real_type> freq;
    std::vector<real_type> gene_freq;
    std::vector<real_type> pi_f_freq;
    std::vector<real_type> pi_f_genotypes;
    std::vector<real_type> Pop_mig;
    std::vector<real_type> probs;
    std::vector<real_type> y;
  };
  model(const dust::pars_type<model>& pars) :
    shared(pars.shared), internal(pars.internal) {
  }
  size_t size() const {
    return shared->dim_Pop + shared->dim_Pop_tot + 1;
  }
  std::vector<real_type> initial(size_t step, rng_state_type& rng_state) {
    std::vector<real_type> state(shared->dim_Pop + shared->dim_Pop_tot + 1);
    state[0] = shared->initial_time;
    std::copy(shared->initial_Pop_tot.begin(), shared->initial_Pop_tot.end(), state.begin() + 1);
    std::copy(shared->initial_Pop.begin(), shared->initial_Pop.end(), state.begin() + shared->offset_variable_Pop);
    return state;
  }
  void update(size_t step, const real_type * state, rng_state_type& rng_state, real_type * state_next) {
    const real_type time = state[0];
    const real_type * Pop = state + shared->offset_variable_Pop;
    real_type mig_num = dust::random::binomial<real_type>(rng_state, shared->capacity, dust::math::exp(shared->m));
    real_type Pop_size = odin_sum2<real_type>(Pop, 0, shared->GPSC_no, 0, shared->sero_no, shared->dim_Pop_1);
    state_next[0] = (step + 1) * shared->dt;
    for (int i = 1; i <= shared->dim_gene_freq_1; ++i) {
      for (int j = 1; j <= shared->dim_gene_freq_2; ++j) {
        internal.gene_freq[i - 1 + shared->dim_gene_freq_1 * (j - 1)] = shared->Genotypes[shared->dim_Genotypes_1 * (j - 1) + i - 1] * odin_sum2<real_type>(Pop, j - 1, j, 0, shared->sero_no, shared->dim_Pop_1);
      }
    }
    for (int i = 1; i <= shared->dim_Pop_mig_1; ++i) {
      for (int j = 1; j <= shared->dim_Pop_mig_2; ++j) {
        internal.Pop_mig[i - 1 + shared->dim_Pop_mig_1 * (j - 1)] = dust::random::binomial<real_type>(rng_state, mig_num, shared->Pop_mig_dist[shared->dim_Pop_mig_dist_1 * (j - 1) + i - 1]);
      }
    }
    for (int i = 1; i <= shared->dim_freq; ++i) {
      internal.freq[i - 1] = odin_sum2<real_type>(internal.gene_freq.data(), i - 1, i, 0, shared->GPSC_no, shared->dim_gene_freq_1) / (real_type) Pop_size;
    }
    for (int i = 1; i <= shared->dim_pi_f_freq_1; ++i) {
      for (int j = 1; j <= shared->dim_pi_f_freq_2; ++j) {
        internal.pi_f_freq[i - 1 + shared->dim_pi_f_freq_1 * (j - 1)] = ((shared->delta[i - 1] <= shared->prop_f * shared->gene_no) ? shared->Genotypes[shared->dim_Genotypes_1 * (j - 1) + i - 1] * (shared->eq[i - 1] - internal.freq[i - 1]) : 0);
      }
    }
    for (int i = 1; i <= shared->dim_pi_f_genotypes; ++i) {
      internal.pi_f_genotypes[i - 1] = odin_sum2<real_type>(internal.pi_f_freq.data(), 0, shared->gene_no, i - 1, i, shared->dim_pi_f_freq_1);
    }
    for (int i = 1; i <= shared->dim_probs_1; ++i) {
      for (int j = 1; j <= shared->dim_probs_2; ++j) {
        internal.probs[i - 1 + shared->dim_probs_1 * (j - 1)] = dust::math::pow<real_type>((1 + dust::math::exp(shared->sigma_f)), internal.pi_f_genotypes[i - 1]) * Pop[shared->dim_Pop_1 * (j - 1) + i - 1] * (1 - (static_cast<int>(time >= shared->vacc_time) * shared->vaccTypes[j - 1] * shared->v));
      }
    }
    for (int i = 1; i <= shared->dim_y_1; ++i) {
      for (int j = 1; j <= shared->dim_y_2; ++j) {
        internal.y[i - 1 + shared->dim_y_1 * (j - 1)] = dust::random::poisson<real_type>(rng_state, shared->capacity * (internal.probs[shared->dim_probs_1 * (j - 1) + i - 1] / (real_type) odin_sum2<real_type>(internal.probs.data(), 0, shared->GPSC_no, 0, shared->sero_no, shared->dim_probs_1)) * (1 - dust::math::exp(shared->m)));
      }
    }
    for (int i = 1; i <= shared->dim_Pop_1; ++i) {
      for (int j = 1; j <= shared->dim_Pop_2; ++j) {
        state_next[shared->offset_variable_Pop + i - 1 + shared->dim_Pop_1 * (j - 1)] = internal.y[shared->dim_y_1 * (j - 1) + i - 1] + internal.Pop_mig[shared->dim_Pop_mig_1 * (j - 1) + i - 1];
      }
    }
    for (int i = 1; i <= shared->dim_Pop_tot; ++i) {
      state_next[1 + i - 1] = odin_sum2<real_type>(internal.y.data(), i - 1, i, 0, shared->dim_y_2, shared->dim_y_1) + odin_sum2<real_type>(internal.Pop_mig.data(), i - 1, i, 0, shared->dim_Pop_mig_2, shared->dim_Pop_mig_1);
    }
  }
private:
  std::shared_ptr<const shared_type> shared;
  internal_type internal;
};
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum2(const container x, int from_i, int to_i, int from_j, int to_j, int dim_x_1) {
  real_type tot = 0.0;
  for (int j = from_j; j < to_j; ++j) {
    int jj = j * dim_x_1;
    for (int i = from_i; i < to_i; ++i) {
      tot += x[i + jj];
    }
  }
  return tot;
}
#include <array>
#include <cpp11/R.hpp>
#include <cpp11/sexp.hpp>
#include <cpp11/doubles.hpp>
#include <cpp11/integers.hpp>
#include <cpp11/list.hpp>
#include <cpp11/strings.hpp>
#include <memory>
#include <vector>

template <typename T>
inline bool is_na(T x);

template <>
inline bool is_na(int x) {
  return x == NA_INTEGER;
}

template <>
inline bool is_na(double x) {
  return ISNA(x);
}

inline size_t object_length(cpp11::sexp x) {
  return ::Rf_xlength(x);
}

template <typename T>
void user_check_value(T value, const char *name, T min, T max) {
  if (is_na(value)) {
    cpp11::stop("'%s' must not be NA", name);
  }
  if (!is_na(min) && value < min) {
    cpp11::stop("Expected '%s' to be at least %g", name, (double) min);
  }
  if (!is_na(max) && value > max) {
    cpp11::stop("Expected '%s' to be at most %g", name, (double) max);
  }
}

template <typename T>
void user_check_array_value(const std::vector<T>& value, const char *name,
                            T min, T max) {
  for (auto& x : value) {
    user_check_value(x, name, min, max);
  }
}

inline size_t user_get_array_rank(cpp11::sexp x) {
  if (!::Rf_isArray(x)) {
    return 1;
  } else {
    cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
    return dim.size();
  }
}

template <size_t N>
void user_check_array_rank(cpp11::sexp x, const char *name) {
  size_t rank = user_get_array_rank(x);
  if (rank != N) {
    if (N == 1) {
      cpp11::stop("Expected a vector for '%s'", name);
    } else if (N == 2) {
      cpp11::stop("Expected a matrix for '%s'", name);
    } else {
      cpp11::stop("Expected an array of rank %d for '%s'",
                  static_cast<int>(N), name);
    }
  }
}

template <size_t N>
void user_check_array_dim(cpp11::sexp x, const char *name,
                          const std::array<int, N>& dim_expected) {
  cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  for (size_t i = 0; i < N; ++i) {
    if (dim[(int)i] != dim_expected[i]) {
      Rf_error("Incorrect size of dimension %d of '%s' (expected %d)",
               static_cast<int>(i + 1), name, dim_expected[i]);
    }
  }
}

template <>
inline void user_check_array_dim<1>(cpp11::sexp x, const char *name,
                                    const std::array<int, 1>& dim_expected) {
  if ((int)object_length(x) != dim_expected[0]) {
    cpp11::stop("Expected length %d value for '%s'", dim_expected[0], name);
  }
}

template <size_t N>
void user_set_array_dim(cpp11::sexp x, const char *name,
                        std::array<int, N>& dim) {
  cpp11::integers dim_given = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  std::copy(dim_given.begin(), dim_given.end(), dim.begin());
}

template <>
inline void user_set_array_dim<1>(cpp11::sexp x, const char *name,
                                  std::array<int, 1>& dim) {
  dim[0] = object_length(x);
}

template <typename T>
T user_get_scalar(cpp11::list user, const char *name,
                  const T previous, T min, T max) {
  T ret = previous;
  cpp11::sexp x = user[name];
  if (x != R_NilValue) {
    if (object_length(x) != 1) {
      cpp11::stop("Expected a scalar numeric for '%s'", name);
    }
    // TODO: when we're getting out an integer this is a bit too relaxed
    if (TYPEOF(x) == REALSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else if (TYPEOF(x) == INTSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else {
      cpp11::stop("Expected a numeric value for %s", name);
    }
  }

  if (is_na(ret)) {
    cpp11::stop("Expected a value for '%s'", name);
  }
  user_check_value<T>(ret, name, min, max);
  return ret;
}

template <>
inline float user_get_scalar<float>(cpp11::list user, const char *name,
                                    const float previous, float min, float max) {
  double value = user_get_scalar<double>(user, name, previous, min, max);
  return static_cast<float>(value);
}

template <typename T>
std::vector<T> user_get_array_value(cpp11::sexp x, const char * name,
                                    T min, T max) {
  std::vector<T> ret = cpp11::as_cpp<std::vector<T>>(x);
  user_check_array_value<T>(ret, name, min, max);
  return ret;
}

template <typename T, size_t N>
std::vector<T> user_get_array_fixed(cpp11::list user, const char *name,
                                    const std::vector<T> previous,
                                    const std::array<int, N>& dim,
                                    T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_check_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <typename T, size_t N>
std::vector<T> user_get_array_variable(cpp11::list user, const char *name,
                                       std::vector<T> previous,
                                       std::array<int, N>& dim,
                                       T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_set_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <>
inline std::vector<float> user_get_array_value(cpp11::sexp x, const char * name,
                                               float min, float max) {
  // NOTE: possible under/overflow here for min/max because we've
  // downcast this.
  std::vector<double> value = user_get_array_value<double>(x, name, min, max);
  std::vector<float> ret(value.size());
  std::copy(value.begin(), value.end(), ret.begin());
  return ret;
}

// This is sum with inclusive "from", exclusive "to", following the
// same function in odin
template <typename real_type, typename container>
__host__ __device__
real_type odin_sum1(const container x, size_t from, size_t to) {
  real_type tot = 0.0;
  for (size_t i = from; i < to; ++i) {
    tot += x[i];
  }
  return tot;
}

inline cpp11::writable::integers integer_sequence(size_t from, size_t len) {
  cpp11::writable::integers ret(len);
  int* data = INTEGER(ret);
  for (size_t i = 0, j = from; i < len; ++i, ++j) {
    data[i] = j;
  }
  return ret;
}
namespace dust {
template<>
dust::pars_type<model> dust_pars<model>(cpp11::list user) {
  using real_type = typename model::real_type;
  auto shared = std::make_shared<model::shared_type>();
  model::internal_type internal;
  shared->initial_time = 0;
  shared->capacity = NA_REAL;
  shared->gene_no = NA_INTEGER;
  shared->GPSC_no = NA_INTEGER;
  shared->m = NA_REAL;
  shared->prop_f = NA_REAL;
  shared->sero_no = NA_INTEGER;
  shared->sigma_f = NA_REAL;
  shared->v = NA_REAL;
  shared->vacc_time = NA_REAL;
  shared->dt = 1;
  shared->capacity = user_get_scalar<real_type>(user, "capacity", shared->capacity, NA_REAL, NA_REAL);
  shared->dt = user_get_scalar<real_type>(user, "dt", shared->dt, NA_REAL, NA_REAL);
  shared->gene_no = user_get_scalar<int>(user, "gene_no", shared->gene_no, NA_INTEGER, NA_INTEGER);
  shared->GPSC_no = user_get_scalar<int>(user, "GPSC_no", shared->GPSC_no, NA_INTEGER, NA_INTEGER);
  shared->m = user_get_scalar<real_type>(user, "m", shared->m, NA_REAL, NA_REAL);
  shared->prop_f = user_get_scalar<real_type>(user, "prop_f", shared->prop_f, NA_REAL, NA_REAL);
  shared->sero_no = user_get_scalar<int>(user, "sero_no", shared->sero_no, NA_INTEGER, NA_INTEGER);
  shared->sigma_f = user_get_scalar<real_type>(user, "sigma_f", shared->sigma_f, NA_REAL, NA_REAL);
  shared->v = user_get_scalar<real_type>(user, "v", shared->v, NA_REAL, NA_REAL);
  shared->vacc_time = user_get_scalar<real_type>(user, "vacc_time", shared->vacc_time, NA_REAL, NA_REAL);
  shared->dim_delta = shared->gene_no;
  shared->dim_eq = shared->gene_no;
  shared->dim_freq = shared->gene_no;
  shared->dim_gene_eq_1 = shared->gene_no;
  shared->dim_gene_eq_2 = shared->GPSC_no;
  shared->dim_gene_freq_1 = shared->gene_no;
  shared->dim_gene_freq_2 = shared->GPSC_no;
  shared->dim_Genotypes_1 = shared->gene_no;
  shared->dim_Genotypes_2 = shared->GPSC_no;
  shared->dim_pi_f_freq_1 = shared->gene_no;
  shared->dim_pi_f_freq_2 = shared->GPSC_no;
  shared->dim_pi_f_genotypes = shared->GPSC_no;
  shared->dim_Pop_1 = shared->GPSC_no;
  shared->dim_Pop_2 = shared->sero_no;
  shared->dim_Pop_eq = shared->GPSC_no;
  shared->dim_Pop_mig_1 = shared->GPSC_no;
  shared->dim_Pop_mig_2 = shared->sero_no;
  shared->dim_Pop_mig_dist_1 = shared->GPSC_no;
  shared->dim_Pop_mig_dist_2 = shared->sero_no;
  shared->dim_Pop_start_1 = shared->GPSC_no;
  shared->dim_Pop_start_2 = shared->sero_no;
  shared->dim_Pop_tot = shared->GPSC_no;
  shared->dim_probs_1 = shared->GPSC_no;
  shared->dim_probs_2 = shared->sero_no;
  shared->dim_vaccTypes = shared->sero_no;
  shared->dim_y_1 = shared->GPSC_no;
  shared->dim_y_2 = shared->sero_no;
  shared->eq = std::vector<real_type>(shared->dim_eq);
  internal.freq = std::vector<real_type>(shared->dim_freq);
  shared->initial_Pop_tot = std::vector<real_type>(shared->dim_Pop_tot);
  internal.pi_f_genotypes = std::vector<real_type>(shared->dim_pi_f_genotypes);
  shared->delta = user_get_array_fixed<real_type, 1>(user, "delta", shared->delta, {shared->dim_delta}, NA_REAL, NA_REAL);
  shared->dim_gene_eq = shared->dim_gene_eq_1 * shared->dim_gene_eq_2;
  shared->dim_gene_freq = shared->dim_gene_freq_1 * shared->dim_gene_freq_2;
  shared->dim_Genotypes = shared->dim_Genotypes_1 * shared->dim_Genotypes_2;
  shared->dim_pi_f_freq = shared->dim_pi_f_freq_1 * shared->dim_pi_f_freq_2;
  shared->dim_Pop = shared->dim_Pop_1 * shared->dim_Pop_2;
  shared->dim_Pop_mig = shared->dim_Pop_mig_1 * shared->dim_Pop_mig_2;
  shared->dim_Pop_mig_dist = shared->dim_Pop_mig_dist_1 * shared->dim_Pop_mig_dist_2;
  shared->dim_Pop_start = shared->dim_Pop_start_1 * shared->dim_Pop_start_2;
  shared->dim_probs = shared->dim_probs_1 * shared->dim_probs_2;
  shared->dim_y = shared->dim_y_1 * shared->dim_y_2;
  shared->offset_variable_Pop = shared->dim_Pop_tot + 1;
  shared->Pop_eq = user_get_array_fixed<real_type, 1>(user, "Pop_eq", shared->Pop_eq, {shared->dim_Pop_eq}, NA_REAL, NA_REAL);
  shared->vaccTypes = user_get_array_fixed<real_type, 1>(user, "vaccTypes", shared->vaccTypes, {shared->dim_vaccTypes}, NA_REAL, NA_REAL);
  shared->gene_eq = std::vector<real_type>(shared->dim_gene_eq);
  internal.gene_freq = std::vector<real_type>(shared->dim_gene_freq);
  shared->initial_Pop = std::vector<real_type>(shared->dim_Pop);
  internal.pi_f_freq = std::vector<real_type>(shared->dim_pi_f_freq);
  internal.Pop_mig = std::vector<real_type>(shared->dim_Pop_mig);
  internal.probs = std::vector<real_type>(shared->dim_probs);
  internal.y = std::vector<real_type>(shared->dim_y);
  shared->Genotypes = user_get_array_fixed<real_type, 2>(user, "Genotypes", shared->Genotypes, {shared->dim_Genotypes_1, shared->dim_Genotypes_2}, NA_REAL, NA_REAL);
  shared->Pop_mig_dist = user_get_array_fixed<real_type, 2>(user, "Pop_mig_dist", shared->Pop_mig_dist, {shared->dim_Pop_mig_dist_1, shared->dim_Pop_mig_dist_2}, NA_REAL, NA_REAL);
  shared->Pop_start = user_get_array_fixed<real_type, 2>(user, "Pop_start", shared->Pop_start, {shared->dim_Pop_start_1, shared->dim_Pop_start_2}, NA_REAL, NA_REAL);
  for (int i = 1; i <= shared->dim_gene_eq_1; ++i) {
    for (int j = 1; j <= shared->dim_gene_eq_2; ++j) {
      shared->gene_eq[i - 1 + shared->dim_gene_eq_1 * (j - 1)] = shared->Genotypes[shared->dim_Genotypes_1 * (j - 1) + i - 1] * shared->Pop_eq[j - 1];
    }
  }
  for (int i = 1; i <= shared->dim_Pop_1; ++i) {
    for (int j = 1; j <= shared->dim_Pop_2; ++j) {
      shared->initial_Pop[i - 1 + shared->dim_Pop_1 * (j - 1)] = shared->Pop_start[shared->dim_Pop_start_1 * (j - 1) + i - 1];
    }
  }
  for (int i = 1; i <= shared->dim_Pop_tot; ++i) {
    shared->initial_Pop_tot[i - 1] = odin_sum2<real_type>(shared->Pop_start.data(), i - 1, i, 0, shared->dim_Pop_start_2, shared->dim_Pop_start_1);
  }
  for (int i = 1; i <= shared->dim_eq; ++i) {
    shared->eq[i - 1] = odin_sum2<real_type>(shared->gene_eq.data(), i - 1, i, 0, shared->GPSC_no, shared->dim_gene_eq_1) / (real_type) odin_sum1<real_type>(shared->Pop_eq.data(), 0, shared->GPSC_no);
  }
  return dust::pars_type<model>(shared, internal);
}
template <>
cpp11::sexp dust_info<model>(const dust::pars_type<model>& pars) {
  const std::shared_ptr<const model::shared_type> shared = pars.shared;
  cpp11::writable::strings nms({"time", "Pop_tot", "Pop"});
  cpp11::writable::list dim(3);
  dim[0] = cpp11::writable::integers({1});
  dim[1] = cpp11::writable::integers({shared->dim_Pop_tot});
  dim[2] = cpp11::writable::integers({shared->dim_Pop_1, shared->dim_Pop_2});
  dim.names() = nms;
  cpp11::writable::list index(3);
  index[0] = cpp11::writable::integers({1});
  index[1] = integer_sequence(2, shared->dim_Pop_tot);
  index[2] = integer_sequence(shared->offset_variable_Pop + 1, shared->dim_Pop);
  index.names() = nms;
  size_t len = shared->offset_variable_Pop + shared->dim_Pop;
  using namespace cpp11::literals;
  return cpp11::writable::list({
           "dim"_nm = dim,
           "len"_nm = len,
           "index"_nm = index});
}
}

cpp11::sexp dust_model_gpu_info() {
  return dust::gpu::r::gpu_info();
}
using model_cpu = dust::dust_cpu<model>;

cpp11::sexp dust_cpu_model_capabilities() {
  return dust::r::dust_capabilities<model_cpu>();
}

SEXP dust_cpu_model_alloc(cpp11::list r_pars, bool pars_multi, cpp11::sexp r_time,
                             cpp11::sexp r_n_particles, int n_threads,
                             cpp11::sexp r_seed, bool deterministic,
                             cpp11::sexp gpu_config, cpp11::sexp ode_control) {
  return dust::r::dust_cpu_alloc<model>(r_pars, pars_multi, r_time, r_n_particles,
                                        n_threads, r_seed, deterministic,
                                        gpu_config, ode_control);
}

SEXP dust_cpu_model_run(SEXP ptr, cpp11::sexp r_time_end) {
  return dust::r::dust_run<model_cpu>(ptr, r_time_end);
}

SEXP dust_cpu_model_simulate(SEXP ptr, cpp11::sexp r_time_end) {
  return dust::r::dust_simulate<model_cpu>(ptr, r_time_end);
}

SEXP dust_cpu_model_run_adjoint(SEXP ptr) {
  return dust::r::dust_run_adjoint<model_cpu>(ptr);
}

SEXP dust_cpu_model_set_index(SEXP ptr, cpp11::sexp r_index) {
  dust::r::dust_set_index<model_cpu>(ptr, r_index);
  return R_NilValue;
}

SEXP dust_cpu_model_update_state(SEXP ptr, SEXP r_pars, SEXP r_state,
                                           SEXP r_time, SEXP r_set_initial_state, SEXP index, SEXP reset_step_size) {
  return dust::r::dust_update_state<model_cpu>(ptr, r_pars, r_state, r_time,
                                                      r_set_initial_state, index, reset_step_size);
}

SEXP dust_cpu_model_state(SEXP ptr, SEXP r_index) {
  return dust::r::dust_state<model_cpu>(ptr, r_index);
}

SEXP dust_cpu_model_time(SEXP ptr) {
  return dust::r::dust_time<model_cpu>(ptr);
}

void dust_cpu_model_reorder(SEXP ptr, cpp11::sexp r_index) {
  return dust::r::dust_reorder<model_cpu>(ptr, r_index);
}

SEXP dust_cpu_model_resample(SEXP ptr, cpp11::doubles r_weights) {
  return dust::r::dust_resample<model_cpu>(ptr, r_weights);
}

SEXP dust_cpu_model_rng_state(SEXP ptr, bool first_only, bool last_only) {
  return dust::r::dust_rng_state<model_cpu>(ptr, first_only, last_only);
}

SEXP dust_cpu_model_set_rng_state(SEXP ptr, cpp11::raws rng_state) {
  dust::r::dust_set_rng_state<model_cpu>(ptr, rng_state);
  return R_NilValue;
}

SEXP dust_cpu_model_set_data(SEXP ptr, cpp11::list data,
                                       bool shared) {
  dust::r::dust_set_data<model_cpu>(ptr, data, shared);
  return R_NilValue;
}

SEXP dust_cpu_model_compare_data(SEXP ptr) {
  return dust::r::dust_compare_data<model_cpu>(ptr);
}

SEXP dust_cpu_model_filter(SEXP ptr, SEXP time_end,
                                     bool save_trajectories,
                                     cpp11::sexp time_snapshot,
                                     cpp11::sexp min_log_likelihood) {
  return dust::r::dust_filter<model_cpu>(ptr, time_end,
                                                save_trajectories,
                                                time_snapshot,
                                                min_log_likelihood);
}

void dust_cpu_model_set_n_threads(SEXP ptr, int n_threads) {
  return dust::r::dust_set_n_threads<model_cpu>(ptr, n_threads);
}

int dust_cpu_model_n_state(SEXP ptr) {
  return dust::r::dust_n_state<model_cpu>(ptr);
}

void dust_cpu_model_set_stochastic_schedule(SEXP ptr, SEXP time) {
  dust::r::dust_set_stochastic_schedule<model_cpu>(ptr, time);
}

SEXP dust_cpu_model_ode_statistics(SEXP ptr) {
  return dust::r::dust_ode_statistics<model_cpu>(ptr);
}
